/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _src_main__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);\n\n\n(() => {\n  // Wait for DOM to be fully loaded\n  document.addEventListener('DOMContentLoaded', () => {\n    /* eslint-disable no-new */\n    new _src_main__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n      first: 'wow',\n      third: ''\n    });\n  });\n})();\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy1saWJyYXJ5L01ITS9NSE0uanM/ZWQwZiJdLCJuYW1lcyI6WyJkb2N1bWVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJmaXJzdCIsInRoaXJkIl0sIm1hcHBpbmdzIjoiOztBQUFBOztBQUVBLENBQUMsTUFBTTtBQUNMO0FBQ0FBLFdBQVNDLGdCQUFULENBQTBCLGtCQUExQixFQUE4QyxNQUFNO0FBQ2xEO0FBQ0EsUUFBSSxpREFBSixDQUFRO0FBQ05DLGFBQU8sS0FERDtBQUVOQyxhQUFPO0FBRkQsS0FBUjtBQUlELEdBTkQ7QUFPRCxDQVREIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTUhNIGZyb20gJy4vc3JjL21haW4nXG5cbigoKSA9PiB7XG4gIC8vIFdhaXQgZm9yIERPTSB0byBiZSBmdWxseSBsb2FkZWRcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsICgpID0+IHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1uZXcgKi9cbiAgICBuZXcgTUhNKHtcbiAgICAgIGZpcnN0OiAnd293JyxcbiAgICAgIHRoaXJkOiAnJ1xuICAgIH0pXG4gIH0pXG59KSgpXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return MHM; });\nclass MHM {\n  constructor(opts) {\n    this.opts = opts;\n\n    // DEFAULTS\n    opts = {\n      first: this.opts.first || 'default value',\n      second: this.opts.second || 'default value',\n      third: this.opts.third || 'default value'\n\n      // ELEMENTS\n    };this.elements = {\n      snappers: {\n        linksList: document.querySelectorAll(`[data-mhm-item=\"snapper\"]`),\n        mainSnapper: document.querySelector('[data-mhm-offset]')\n      },\n      togglers: document.querySelectorAll(`[data-mhm-item=\"toggler\"]`),\n      scrollers: document.querySelector(`[data-mhm-scroll-sections]`)\n\n      /**\n      * Invokes methods based on the availability of the DOM elements they rely on.\n      */\n    };this.methodsLoaded = [];\n\n    this.init();\n\n    // Load message\n    console.info(`%c[MHM Utility Framework loaded: %c${this.methodsLoaded.length ? this.methodsLoaded : 'NO functions loaded'}%c]`, 'color:blue;', 'color:green; font-weight:bold;', 'color:blue;');\n  }\n\n  // UTILS\n\n  /**\n   * Invokes methods based on the availability of the DOM elements they rely on.\n   *\n   * @param {array} elementAndFns - Array of arrays made of elements which if available in\n   * the DOM invoke the method within that same array. (confusing, isn't it?)\n   * @returns {function} - Invokes methods passed to elementsAndFns\n   */\n  invokeIfNeeded(elementAndFns) {\n    elementAndFns.forEach(elementAndFn => {\n      const [el, fn] = elementAndFn;\n      if (el.length || el) {\n        this.methodsLoaded.push(fn.name);\n        return fn.apply(this);\n      }\n    });\n  }\n\n  /**\n   * Invokes the needed methods.\n   *\n   */\n  init() {\n    this.invokeIfNeeded([[this.elements.snappers.linksList, this.snapper], [this.elements.togglers, this.toggler], [this.elements.scrollers, this.scroller]]);\n  }\n\n  /**\n   * Scans the DOM for a 'Snapper' based on the constructor's\n   * {this.elements.snapper.mainSnapper} and adds a click eventListener to each of the snap links\n   * Each links is connected to the snapping position through unique attributes thatneed to match\n   * in order to trigger the snap-to: the former being 'data-mhm-target' and the\n   * latter 'data-mhm-id'. In {this.elements.snapper.mainSnapper} we need to define a\n   * 'data-mhm-offset' that gets the height of the element passed here and adds it to the top but just\n   * if that element, probably a header, is position:fixed\n   */\n  snapper() {\n    const isFixed = el => window.getComputedStyle(el).position === 'fixed',\n          offsetHeight = this.elements.snappers.mainSnapper ? this.elements.snappers.mainSnapper.offsetHeight : 0;\n\n    this.elements.snappers.linksList.forEach(snapper => {\n      const snappersItems = snapper.querySelectorAll('[data-mhm-target]');\n\n      snappersItems.forEach(snappersItem => {\n        snappersItem.addEventListener('click', () => {\n          const targetId = snappersItem.getAttribute('data-mhm-target'),\n                target = document.querySelector(`[data-mhm-id=${targetId}]`),\n                targetPosition = target ? target.getBoundingClientRect().top : 0,\n                mainSnapperTarget = document.querySelector(`#${this.elements.snappers.mainSnapper.getAttribute('data-mhm-offset')}`),\n                topScrollOffset = isFixed(mainSnapperTarget) ? Math.floor(window.pageYOffset + targetPosition - offsetHeight) : Math.floor(window.pageYOffset + targetPosition);\n\n          window.scrollTo({\n            top: topScrollOffset,\n            behavior: 'smooth'\n          });\n        });\n      });\n    });\n  }\n\n  /**\n   * Scans the DOM for 'Togglers' based on the constructor's\n   * {this.elements.togglers} and adds a click eventListener to each of the toggle elements.\n   * Each 'toggler' is connected to an element through unique attributes that\n   * need to match in order to trigger the snap-to: the former being 'data-mhm-target' and the\n   * latter 'data-mhm-id'. The class that needs toggling needs to be defined with an attribute\n   * being 'data-mhm-class'\n   */\n  toggler() {\n    this.elements.togglers.forEach(toggler => {\n      const targetId = toggler.getAttribute('data-mhm-target'),\n            classToToggle = toggler.getAttribute('data-mhm-class'),\n            target = document.querySelector(`[data-mhm-id=${targetId}]`);\n      toggler.addEventListener('click', () => {\n        target.classList.toggle(classToToggle);\n      });\n    });\n  }\n\n  scroller() {\n    let currentSection = '0';\n    const sections = this.elements.scrollers.querySelectorAll('[data-mhm-scroll-section]'),\n          arrows = document.querySelectorAll('[data-mhm-scroll-arrow]'),\n          lastSection = sections.length - 1,\n          arrowUp = document.querySelector('[data-mhm-scroll-arrow=\"up\"]'),\n          arrowDown = document.querySelector('[data-mhm-scroll-arrow=\"down\"]'),\n          jumpTo = arrow => {\n      const up = arrow.getAttribute('data-mhm-scroll-arrow') === 'up',\n            sectionToScrollToID = up ? Number(currentSection) - 1 : Number(currentSection) + 1,\n            sectionToScrollTo = document.querySelector(`[data-mhm-scroll-section=\"${sectionToScrollToID}\"]`),\n            sectionToScrollToScrollY = sectionToScrollTo.getBoundingClientRect().top;\n      window.scrollTo({\n        top: sectionToScrollToScrollY + window.scrollY,\n        behavior: 'smooth'\n      });\n    },\n          observerProps = {\n      opts: {\n        root: null,\n        rootMargin: '0px',\n        threshold: 0.75\n      },\n      updateCurrentSection: e => {\n        // Update currentSection\n        if (e[0].intersectionRatio >= 0.75) {\n          currentSection = e[0].target.getAttribute('data-mhm-scroll-section');\n        }\n        // Toggle Arrows conditionally to first/last section\n        if (Number(currentSection) === lastSection) {\n          arrowDown.style.display = 'none';\n        } else if (Number(currentSection) === 0) {\n          arrowUp.style.display = 'none';\n        } else {\n          arrowUp.style.display = 'block';\n          arrowDown.style.display = 'block';\n        }\n      }\n    };\n    sections.forEach(section => {\n      const obs = new window.IntersectionObserver(observerProps.updateCurrentSection, observerProps.opts);\n      obs.observe(section);\n    });\n    arrows.forEach(arrow => {\n      arrow.addEventListener('click', e => jumpTo(e.target));\n    });\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy1saWJyYXJ5L01ITS9zcmMvbWFpbi5qcz80MzFhIl0sIm5hbWVzIjpbIk1ITSIsImNvbnN0cnVjdG9yIiwib3B0cyIsImZpcnN0Iiwic2Vjb25kIiwidGhpcmQiLCJlbGVtZW50cyIsInNuYXBwZXJzIiwibGlua3NMaXN0IiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwibWFpblNuYXBwZXIiLCJxdWVyeVNlbGVjdG9yIiwidG9nZ2xlcnMiLCJzY3JvbGxlcnMiLCJtZXRob2RzTG9hZGVkIiwiaW5pdCIsImNvbnNvbGUiLCJpbmZvIiwibGVuZ3RoIiwiaW52b2tlSWZOZWVkZWQiLCJlbGVtZW50QW5kRm5zIiwiZm9yRWFjaCIsImVsZW1lbnRBbmRGbiIsImVsIiwiZm4iLCJwdXNoIiwibmFtZSIsImFwcGx5Iiwic25hcHBlciIsInRvZ2dsZXIiLCJzY3JvbGxlciIsImlzRml4ZWQiLCJ3aW5kb3ciLCJnZXRDb21wdXRlZFN0eWxlIiwicG9zaXRpb24iLCJvZmZzZXRIZWlnaHQiLCJzbmFwcGVyc0l0ZW1zIiwic25hcHBlcnNJdGVtIiwiYWRkRXZlbnRMaXN0ZW5lciIsInRhcmdldElkIiwiZ2V0QXR0cmlidXRlIiwidGFyZ2V0IiwidGFyZ2V0UG9zaXRpb24iLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ0b3AiLCJtYWluU25hcHBlclRhcmdldCIsInRvcFNjcm9sbE9mZnNldCIsIk1hdGgiLCJmbG9vciIsInBhZ2VZT2Zmc2V0Iiwic2Nyb2xsVG8iLCJiZWhhdmlvciIsImNsYXNzVG9Ub2dnbGUiLCJjbGFzc0xpc3QiLCJ0b2dnbGUiLCJjdXJyZW50U2VjdGlvbiIsInNlY3Rpb25zIiwiYXJyb3dzIiwibGFzdFNlY3Rpb24iLCJhcnJvd1VwIiwiYXJyb3dEb3duIiwianVtcFRvIiwiYXJyb3ciLCJ1cCIsInNlY3Rpb25Ub1Njcm9sbFRvSUQiLCJOdW1iZXIiLCJzZWN0aW9uVG9TY3JvbGxUbyIsInNlY3Rpb25Ub1Njcm9sbFRvU2Nyb2xsWSIsInNjcm9sbFkiLCJvYnNlcnZlclByb3BzIiwicm9vdCIsInJvb3RNYXJnaW4iLCJ0aHJlc2hvbGQiLCJ1cGRhdGVDdXJyZW50U2VjdGlvbiIsImUiLCJpbnRlcnNlY3Rpb25SYXRpbyIsInN0eWxlIiwiZGlzcGxheSIsInNlY3Rpb24iLCJvYnMiLCJJbnRlcnNlY3Rpb25PYnNlcnZlciIsIm9ic2VydmUiXSwibWFwcGluZ3MiOiI7O0FBQWUsTUFBTUEsR0FBTixDQUFVO0FBQ3ZCQyxjQUFhQyxJQUFiLEVBQW1CO0FBQ2pCLFNBQUtBLElBQUwsR0FBWUEsSUFBWjs7QUFFQTtBQUNBQSxXQUFPO0FBQ0xDLGFBQU8sS0FBS0QsSUFBTCxDQUFVQyxLQUFWLElBQW1CLGVBRHJCO0FBRUxDLGNBQVEsS0FBS0YsSUFBTCxDQUFVRSxNQUFWLElBQW9CLGVBRnZCO0FBR0xDLGFBQU8sS0FBS0gsSUFBTCxDQUFVRyxLQUFWLElBQW1COztBQUc1QjtBQU5PLEtBQVAsQ0FPQSxLQUFLQyxRQUFMLEdBQWdCO0FBQ2RDLGdCQUFVO0FBQ1JDLG1CQUFXQyxTQUFTQyxnQkFBVCxDQUEyQiwyQkFBM0IsQ0FESDtBQUVSQyxxQkFBYUYsU0FBU0csYUFBVCxDQUF1QixtQkFBdkI7QUFGTCxPQURJO0FBS2RDLGdCQUFVSixTQUFTQyxnQkFBVCxDQUEyQiwyQkFBM0IsQ0FMSTtBQU1kSSxpQkFBV0wsU0FBU0csYUFBVCxDQUF3Qiw0QkFBeEI7O0FBR2I7OztBQVRnQixLQUFoQixDQVlBLEtBQUtHLGFBQUwsR0FBcUIsRUFBckI7O0FBRUEsU0FBS0MsSUFBTDs7QUFFQTtBQUNBQyxZQUFRQyxJQUFSLENBQWMsc0NBQXFDLEtBQUtILGFBQUwsQ0FBbUJJLE1BQW5CLEdBQy9DLEtBQUtKLGFBRDBDLEdBQzFCLHFCQUFzQixLQUQvQyxFQUVBLGFBRkEsRUFFZSxnQ0FGZixFQUVpRCxhQUZqRDtBQUdEOztBQUVEOztBQUVBOzs7Ozs7O0FBT0FLLGlCQUFnQkMsYUFBaEIsRUFBK0I7QUFDN0JBLGtCQUFjQyxP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RUFBNEM7QUFDMUNFLG9CQUFVZ0IsS0FBVixDQUFnQkMsT0FBaEIsR0FBMEIsTUFBMUI7QUFDRCxTQUZELE1BRU8sSUFBSVosT0FBT1YsY0FBUCxNQUEyQixDQUEvQixFQUFrQztBQUN2Q0ksa0JBQVFpQixLQUFSLENBQWNDLE9BQWQsR0FBd0IsTUFBeEI7QUFDRCxTQUZNLE1BRUE7QUFDTGxCLGtCQUFRaUIsS0FBUixDQUFjQyxPQUFkLEdBQXdCLE9BQXhCO0FBQ0FqQixvQkFBVWdCLEtBQVYsQ0FBZ0JDLE9BQWhCLEdBQTBCLE9BQTFCO0FBQ0Q7QUFDRjtBQXBCYSxLQWZsQjtBQXFDQXJCLGFBQVNuQyxPQUFULENBQWlCeUQsV0FBVztBQUMxQixZQUFNQyxNQUFNLElBQUkvQyxPQUFPZ0Qsb0JBQVgsQ0FBZ0NYLGNBQWNJLG9CQUE5QyxFQUFvRUosY0FBY3BFLElBQWxGLENBQVo7QUFDQThFLFVBQUlFLE9BQUosQ0FBWUgsT0FBWjtBQUNELEtBSEQ7QUFJQXJCLFdBQU9wQyxPQUFQLENBQWV5QyxTQUFTO0FBQ3RCQSxZQUFNeEIsZ0JBQU4sQ0FBdUIsT0FBdkIsRUFBZ0NvQyxLQUFLYixPQUFPYSxFQUFFakMsTUFBVCxDQUFyQztBQUNELEtBRkQ7QUFHRDtBQXZLc0IiLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGNsYXNzIE1ITSB7XG4gIGNvbnN0cnVjdG9yIChvcHRzKSB7XG4gICAgdGhpcy5vcHRzID0gb3B0c1xuXG4gICAgLy8gREVGQVVMVFNcbiAgICBvcHRzID0ge1xuICAgICAgZmlyc3Q6IHRoaXMub3B0cy5maXJzdCB8fCAnZGVmYXVsdCB2YWx1ZScsXG4gICAgICBzZWNvbmQ6IHRoaXMub3B0cy5zZWNvbmQgfHwgJ2RlZmF1bHQgdmFsdWUnLFxuICAgICAgdGhpcmQ6IHRoaXMub3B0cy50aGlyZCB8fCAnZGVmYXVsdCB2YWx1ZSdcbiAgICB9XG5cbiAgICAvLyBFTEVNRU5UU1xuICAgIHRoaXMuZWxlbWVudHMgPSB7XG4gICAgICBzbmFwcGVyczoge1xuICAgICAgICBsaW5rc0xpc3Q6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYFtkYXRhLW1obS1pdGVtPVwic25hcHBlclwiXWApLFxuICAgICAgICBtYWluU25hcHBlcjogZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW2RhdGEtbWhtLW9mZnNldF0nKVxuICAgICAgfSxcbiAgICAgIHRvZ2dsZXJzOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGBbZGF0YS1taG0taXRlbT1cInRvZ2dsZXJcIl1gKSxcbiAgICAgIHNjcm9sbGVyczogZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgW2RhdGEtbWhtLXNjcm9sbC1zZWN0aW9uc11gKVxuICAgIH1cblxuICAgIC8qKlxuICAgKiBJbnZva2VzIG1ldGhvZHMgYmFzZWQgb24gdGhlIGF2YWlsYWJpbGl0eSBvZiB0aGUgRE9NIGVsZW1lbnRzIHRoZXkgcmVseSBvbi5cbiAgICovXG4gICAgdGhpcy5tZXRob2RzTG9hZGVkID0gW11cblxuICAgIHRoaXMuaW5pdCgpXG5cbiAgICAvLyBMb2FkIG1lc3NhZ2VcbiAgICBjb25zb2xlLmluZm8oYCVjW01ITSBVdGlsaXR5IEZyYW1ld29yayBsb2FkZWQ6ICVjJHt0aGlzLm1ldGhvZHNMb2FkZWQubGVuZ3RoXG4gICAgICA/IHRoaXMubWV0aG9kc0xvYWRlZCA6ICdOTyBmdW5jdGlvbnMgbG9hZGVkJ30lY11gLFxuICAgICdjb2xvcjpibHVlOycsICdjb2xvcjpncmVlbjsgZm9udC13ZWlnaHQ6Ym9sZDsnLCAnY29sb3I6Ymx1ZTsnKVxuICB9XG5cbiAgLy8gVVRJTFNcblxuICAvKipcbiAgICogSW52b2tlcyBtZXRob2RzIGJhc2VkIG9uIHRoZSBhdmFpbGFiaWxpdHkgb2YgdGhlIERPTSBlbGVtZW50cyB0aGV5IHJlbHkgb24uXG4gICAqXG4gICAqIEBwYXJhbSB7YXJyYXl9IGVsZW1lbnRBbmRGbnMgLSBBcnJheSBvZiBhcnJheXMgbWFkZSBvZiBlbGVtZW50cyB3aGljaCBpZiBhdmFpbGFibGUgaW5cbiAgICogdGhlIERPTSBpbnZva2UgdGhlIG1ldGhvZCB3aXRoaW4gdGhhdCBzYW1lIGFycmF5LiAoY29uZnVzaW5nLCBpc24ndCBpdD8pXG4gICAqIEByZXR1cm5zIHtmdW5jdGlvbn0gLSBJbnZva2VzIG1ldGhvZHMgcGFzc2VkIHRvIGVsZW1lbnRzQW5kRm5zXG4gICAqL1xuICBpbnZva2VJZk5lZWRlZCAoZWxlbWVudEFuZEZucykge1xuICAgIGVsZW1lbnRBbmRGbnMuZm9yRWFjaChlbGVtZW50QW5kRm4gPT4ge1xuICAgICAgY29uc3QgW2VsLCBmbl0gPSBlbGVtZW50QW5kRm5cbiAgICAgIGlmIChlbC5sZW5ndGggfHwgZWwpIHtcbiAgICAgICAgdGhpcy5tZXRob2RzTG9hZGVkLnB1c2goZm4ubmFtZSlcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VzIHRoZSBuZWVkZWQgbWV0aG9kcy5cbiAgICpcbiAgICovXG4gIGluaXQgKCkge1xuICAgIHRoaXMuaW52b2tlSWZOZWVkZWQoW1xuICAgICAgW3RoaXMuZWxlbWVudHMuc25hcHBlcnMubGlua3NMaXN0LCB0aGlzLnNuYXBwZXJdLFxuICAgICAgW3RoaXMuZWxlbWVudHMudG9nZ2xlcnMsIHRoaXMudG9nZ2xlcl0sXG4gICAgICBbdGhpcy5lbGVtZW50cy5zY3JvbGxlcnMsIHRoaXMuc2Nyb2xsZXJdXG4gICAgXSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTY2FucyB0aGUgRE9NIGZvciBhICdTbmFwcGVyJyBiYXNlZCBvbiB0aGUgY29uc3RydWN0b3Inc1xuICAgKiB7dGhpcy5lbGVtZW50cy5zbmFwcGVyLm1haW5TbmFwcGVyfSBhbmQgYWRkcyBhIGNsaWNrIGV2ZW50TGlzdGVuZXIgdG8gZWFjaCBvZiB0aGUgc25hcCBsaW5rc1xuICAgKiBFYWNoIGxpbmtzIGlzIGNvbm5lY3RlZCB0byB0aGUgc25hcHBpbmcgcG9zaXRpb24gdGhyb3VnaCB1bmlxdWUgYXR0cmlidXRlcyB0aGF0bmVlZCB0byBtYXRjaFxuICAgKiBpbiBvcmRlciB0byB0cmlnZ2VyIHRoZSBzbmFwLXRvOiB0aGUgZm9ybWVyIGJlaW5nICdkYXRhLW1obS10YXJnZXQnIGFuZCB0aGVcbiAgICogbGF0dGVyICdkYXRhLW1obS1pZCcuIEluIHt0aGlzLmVsZW1lbnRzLnNuYXBwZXIubWFpblNuYXBwZXJ9IHdlIG5lZWQgdG8gZGVmaW5lIGFcbiAgICogJ2RhdGEtbWhtLW9mZnNldCcgdGhhdCBnZXRzIHRoZSBoZWlnaHQgb2YgdGhlIGVsZW1lbnQgcGFzc2VkIGhlcmUgYW5kIGFkZHMgaXQgdG8gdGhlIHRvcCBidXQganVzdFxuICAgKiBpZiB0aGF0IGVsZW1lbnQsIHByb2JhYmx5IGEgaGVhZGVyLCBpcyBwb3NpdGlvbjpmaXhlZFxuICAgKi9cbiAgc25hcHBlciAoKSB7XG4gICAgY29uc3QgaXNGaXhlZCA9IGVsID0+IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJyxcblxuICAgICAgb2Zmc2V0SGVpZ2h0ID0gdGhpcy5lbGVtZW50cy5zbmFwcGVycy5tYWluU25hcHBlclxuICAgICAgICA/IHRoaXMuZWxlbWVudHMuc25hcHBlcnMubWFpblNuYXBwZXIub2Zmc2V0SGVpZ2h0IDogMFxuXG4gICAgdGhpcy5lbGVtZW50cy5zbmFwcGVycy5saW5rc0xpc3QuZm9yRWFjaChzbmFwcGVyID0+IHtcbiAgICAgIGNvbnN0IHNuYXBwZXJzSXRlbXMgPSBzbmFwcGVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLW1obS10YXJnZXRdJylcblxuICAgICAgc25hcHBlcnNJdGVtcy5mb3JFYWNoKHNuYXBwZXJzSXRlbSA9PiB7XG4gICAgICAgIHNuYXBwZXJzSXRlbS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICBjb25zdCB0YXJnZXRJZCA9IHNuYXBwZXJzSXRlbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtbWhtLXRhcmdldCcpLFxuICAgICAgICAgICAgdGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgW2RhdGEtbWhtLWlkPSR7dGFyZ2V0SWR9XWApLFxuICAgICAgICAgICAgdGFyZ2V0UG9zaXRpb24gPSB0YXJnZXQgPyB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wIDogMCxcbiAgICAgICAgICAgIG1haW5TbmFwcGVyVGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgIyR7dGhpcy5lbGVtZW50cy5zbmFwcGVycy5tYWluU25hcHBlci5nZXRBdHRyaWJ1dGUoJ2RhdGEtbWhtLW9mZnNldCcpfWApLFxuICAgICAgICAgICAgdG9wU2Nyb2xsT2Zmc2V0ID0gaXNGaXhlZChtYWluU25hcHBlclRhcmdldClcbiAgICAgICAgICAgICAgPyBNYXRoLmZsb29yKHdpbmRvdy5wYWdlWU9mZnNldCArIHRhcmdldFBvc2l0aW9uIC0gb2Zmc2V0SGVpZ2h0KVxuICAgICAgICAgICAgICA6IE1hdGguZmxvb3Iod2luZG93LnBhZ2VZT2Zmc2V0ICsgdGFyZ2V0UG9zaXRpb24pXG5cbiAgICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oe1xuICAgICAgICAgICAgdG9wOiB0b3BTY3JvbGxPZmZzZXQsXG4gICAgICAgICAgICBiZWhhdmlvcjogJ3Ntb290aCdcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFNjYW5zIHRoZSBET00gZm9yICdUb2dnbGVycycgYmFzZWQgb24gdGhlIGNvbnN0cnVjdG9yJ3NcbiAgICoge3RoaXMuZWxlbWVudHMudG9nZ2xlcnN9IGFuZCBhZGRzIGEgY2xpY2sgZXZlbnRMaXN0ZW5lciB0byBlYWNoIG9mIHRoZSB0b2dnbGUgZWxlbWVudHMuXG4gICAqIEVhY2ggJ3RvZ2dsZXInIGlzIGNvbm5lY3RlZCB0byBhbiBlbGVtZW50IHRocm91Z2ggdW5pcXVlIGF0dHJpYnV0ZXMgdGhhdFxuICAgKiBuZWVkIHRvIG1hdGNoIGluIG9yZGVyIHRvIHRyaWdnZXIgdGhlIHNuYXAtdG86IHRoZSBmb3JtZXIgYmVpbmcgJ2RhdGEtbWhtLXRhcmdldCcgYW5kIHRoZVxuICAgKiBsYXR0ZXIgJ2RhdGEtbWhtLWlkJy4gVGhlIGNsYXNzIHRoYXQgbmVlZHMgdG9nZ2xpbmcgbmVlZHMgdG8gYmUgZGVmaW5lZCB3aXRoIGFuIGF0dHJpYnV0ZVxuICAgKiBiZWluZyAnZGF0YS1taG0tY2xhc3MnXG4gICAqL1xuICB0b2dnbGVyICgpIHtcbiAgICB0aGlzLmVsZW1lbnRzLnRvZ2dsZXJzLmZvckVhY2godG9nZ2xlciA9PiB7XG4gICAgICBjb25zdCB0YXJnZXRJZCA9IHRvZ2dsZXIuZ2V0QXR0cmlidXRlKCdkYXRhLW1obS10YXJnZXQnKSxcbiAgICAgICAgY2xhc3NUb1RvZ2dsZSA9IHRvZ2dsZXIuZ2V0QXR0cmlidXRlKCdkYXRhLW1obS1jbGFzcycpLFxuICAgICAgICB0YXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBbZGF0YS1taG0taWQ9JHt0YXJnZXRJZH1dYClcbiAgICAgIHRvZ2dsZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgIHRhcmdldC5jbGFzc0xpc3QudG9nZ2xlKGNsYXNzVG9Ub2dnbGUpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBzY3JvbGxlciAoKSB7XG4gICAgbGV0IGN1cnJlbnRTZWN0aW9uID0gJzAnXG4gICAgY29uc3Qgc2VjdGlvbnMgPSB0aGlzLmVsZW1lbnRzLnNjcm9sbGVycy5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1taG0tc2Nyb2xsLXNlY3Rpb25dJyksXG4gICAgICBhcnJvd3MgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1taG0tc2Nyb2xsLWFycm93XScpLFxuICAgICAgbGFzdFNlY3Rpb24gPSBzZWN0aW9ucy5sZW5ndGggLSAxLFxuICAgICAgYXJyb3dVcCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLW1obS1zY3JvbGwtYXJyb3c9XCJ1cFwiXScpLFxuICAgICAgYXJyb3dEb3duID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW2RhdGEtbWhtLXNjcm9sbC1hcnJvdz1cImRvd25cIl0nKSxcbiAgICAgIGp1bXBUbyA9IGFycm93ID0+IHtcbiAgICAgICAgY29uc3QgdXAgPSBhcnJvdy5nZXRBdHRyaWJ1dGUoJ2RhdGEtbWhtLXNjcm9sbC1hcnJvdycpID09PSAndXAnLFxuICAgICAgICAgIHNlY3Rpb25Ub1Njcm9sbFRvSUQgPSB1cCA/IE51bWJlcihjdXJyZW50U2VjdGlvbikgLSAxIDogTnVtYmVyKGN1cnJlbnRTZWN0aW9uKSArIDEsXG4gICAgICAgICAgc2VjdGlvblRvU2Nyb2xsVG8gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBbZGF0YS1taG0tc2Nyb2xsLXNlY3Rpb249XCIke3NlY3Rpb25Ub1Njcm9sbFRvSUR9XCJdYCksXG4gICAgICAgICAgc2VjdGlvblRvU2Nyb2xsVG9TY3JvbGxZID0gc2VjdGlvblRvU2Nyb2xsVG8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wXG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbyh7XG4gICAgICAgICAgdG9wOiBzZWN0aW9uVG9TY3JvbGxUb1Njcm9sbFkgKyB3aW5kb3cuc2Nyb2xsWSxcbiAgICAgICAgICBiZWhhdmlvcjogJ3Ntb290aCdcbiAgICAgICAgfSlcbiAgICAgIH0sXG4gICAgICBvYnNlcnZlclByb3BzID0ge1xuICAgICAgICBvcHRzOiB7XG4gICAgICAgICAgcm9vdDogbnVsbCxcbiAgICAgICAgICByb290TWFyZ2luOiAnMHB4JyxcbiAgICAgICAgICB0aHJlc2hvbGQ6IDAuNzVcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlQ3VycmVudFNlY3Rpb246IGUgPT4ge1xuICAgICAgICAgIC8vIFVwZGF0ZSBjdXJyZW50U2VjdGlvblxuICAgICAgICAgIGlmIChlWzBdLmludGVyc2VjdGlvblJhdGlvID49IDAuNzUpIHtcbiAgICAgICAgICAgIGN1cnJlbnRTZWN0aW9uID0gZVswXS50YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLW1obS1zY3JvbGwtc2VjdGlvbicpXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFRvZ2dsZSBBcnJvd3MgY29uZGl0aW9uYWxseSB0byBmaXJzdC9sYXN0IHNlY3Rpb25cbiAgICAgICAgICBpZiAoTnVtYmVyKGN1cnJlbnRTZWN0aW9uKSA9PT0gbGFzdFNlY3Rpb24pIHtcbiAgICAgICAgICAgIGFycm93RG93bi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG4gICAgICAgICAgfSBlbHNlIGlmIChOdW1iZXIoY3VycmVudFNlY3Rpb24pID09PSAwKSB7XG4gICAgICAgICAgICBhcnJvd1VwLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSdcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJyb3dVcC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJ1xuICAgICAgICAgICAgYXJyb3dEb3duLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgc2VjdGlvbnMuZm9yRWFjaChzZWN0aW9uID0+IHtcbiAgICAgIGNvbnN0IG9icyA9IG5ldyB3aW5kb3cuSW50ZXJzZWN0aW9uT2JzZXJ2ZXIob2JzZXJ2ZXJQcm9wcy51cGRhdGVDdXJyZW50U2VjdGlvbiwgb2JzZXJ2ZXJQcm9wcy5vcHRzKVxuICAgICAgb2JzLm9ic2VydmUoc2VjdGlvbilcbiAgICB9KVxuICAgIGFycm93cy5mb3JFYWNoKGFycm93ID0+IHtcbiAgICAgIGFycm93LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZSA9PiBqdW1wVG8oZS50YXJnZXQpKVxuICAgIH0pXG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n");

/***/ })
/******/ ]);